Introduction

Улучшенный механизм восстановления после ошибок является одним из мощных способов увеличения
отказоустойчиваости программы.

Механизм обработки исключений в Java создавался в расчете на написание больших и устойчивыъ программ
, использующих меньше кода, чем было до этого возможно, с большой уверенностью в том, что программа
не имеет необработанных ошибок.

Обработка исключений является в Java единственным официальным способом уведомления об ошибках,
а ее работа облеспечивается компилятором Java

==============
Basic Concepts
==============

Слово "Исключение" следует воспринимать в смысле "возникла исключительная ситуация". Возможно, в точке
возникновения проблемы мы еще не представляем, что же с ней делать, но точно знаем, что уже не можем просто
игнорировать и продолжить выполнение; необходимо остановиться, чтобы кто-то где-то предпринял все
полагающие дествия. Но в текущем контексте мы не располагаем всей нужной информацией для преодоления проблемы.

Другое важное преимущество использования механизма исключения состоит в том, что они значительно
упрощают создание частей программы, отвечающих за обработку ошибок. Вам больше не понадобится выявлять
определенные ошибки в различных местах программы и проверять правильность исполнения метода именно там,
где его вызываем(поскольку исключение гарантирует, что ктото обработает их.Проблему можно решить в
одном месте, так называемом обработчике исключения(exeption handle "обработчик исключения")
Такой подход улучшает структуру программы, так как части, отвечающие за выполненние рабочей задачи,
отделяются от часте, ответственных за обработку ошибок.

===============
Main exceptions
===============

Исключительная ситуация возникат, когда невозможно нормальное прдложение
рабоыт метода или части программы, выполняющейся в данный момент.
Важно отличать исключительную ситуацию от "нормальной" ошибки, когда текущая
обстановка позволяет решить возникшее затруднение. В случае исключительной
ситуации не можем продложить работу программы, т.к. не хватает информации для
решения искоючения в текущем контексте. Все что остается - покинуть
контекст и передать задчу на более выской уровень. Это и произходит когда
возбуждается исключение

Когда возбуждается исключение, происходит следующее:
 1) Создается объект, представляющий исключение(так же как любой объект Java, в куче оператором new
 2) Текущий поток останавливается
 3) Ссылка на объект, представляющая исключение, извлекается из текущеко контекста

 С этого момента включается механизм обработки исключения, который начинает поиск подходящего для продолжения исполнения
 места в программе. Этим местом является обработчик исключений, который пытается решить возникшую проблему так,
 чтобы предпринять другую попыткку выполнения задачи или просто продолжить.

 Пример возбуждения исключения:

 if(t==null){
    throw new NullPointerExeption();
    }

    t - ссылка на объект, которую проверяем, проинициализирована ли она,
    если нет,
    посылаем информацию на более высокий уровень создав объект new NullPointerExeption(),
    и методом throw "вытолкнув" из текущеко контекста.

 Таким образом возбуждаем исключение.

 Исключения позволяют рассматривать все проиходящее в программе как транзакции, для защиты которых используются
 исключения.
 Транзакция - компьютерный аналог договорного права. Если чтото идет не так - отменяем все вычисления.
Исключения также можно рассматривать как втроеннную систему отмены операций, так как в программе можно создать
несколько точек восстановления. Если часть вычислений завершается неудачей, исключение производит "откат"
к последней, заведомо стабильной точке программы.

===================
Arguments exception
===================

Исключения, как  и объекты Java создаются в куче оператором new, который выделяет
память и вызывает конструктор.
Существует 2 вида конструктора:
    -   без аргументов(по умолчанию)
    -   с принимаемым строковым аргументом
    пример:
            throw new NullPointerExeption("t==null")

Используя ключевое слово throw, можно говорить об обработке исключения как об
альтернативном механизма возврата из исполняемого метода. Возврат с выдачей
управления передается не в то место, куда оно было бы возвращено при нормальном
вызове

Возможно возбудить любой тип исключения, происходящих от объекта Throwable(корневой
класс иерархии исключений). Обычно в программе возбуждаются разные типы исключений для
разных типов ошибок. Информация о случившеся ошибке содержится внутри объекта исключения,
а также указывается косвенно  в самом типе этого объекта

==================
Catching exeptions
==================

Охраняемый участок - участок программы, являющийся частью программы, где возможно
появления исключения, за которым следут блок обрабтки исключения.
Если не хотим, чтобы оператор throw завершал работу метода, нужно создать блок try
внутри метода, где будет перехватываться(ловиться) исключение.
    пример:
            try{
                //часть програмы, способная возбуждать исключения
                }

Обработчик исключений - участок в программе после try, выводится
ключевым словом catch:
    пример:
            try{
                 //часть програмы, способная возбуждать исключения
                }catch(Type1 id1){
                    //Перехват исключения Type1
                }catch(Type2 id2){
                    //Перехват исключения Type2
                }catch(Type3 id3){
                    //Перехват исключения Type3
                }
Если возбуждается исключение, механизм обработки исключений ищет первый
из обработчиков исключений, аргумент которого соответствует текущему
типу исключения. После этого он входит в блок catсh и считается что
исключение обработано. После выполнения блока catch поиск обработчика
прекращается.

В теории обработки исключений имеются 2 основные модели:
    * Прерываение:
        Предполагается что ошибка серьезная, нет способов ее исправлния,
        где произошло исключение

    * Возобновление
        Предполагается что обработчик ошибок сделает чтото для исправления ситуации,
        после чего предпринимается попытка повторить неудавшуюся операцию.

Если реализовывать модель возобновления, лучше не возбужлать исключение при
возникновении ошибки а вызвать метод, способный решить проблему. Возможное
так же решение - размещение блока try  в цикле while, который снова и снова
будет обращаться к этому блоку.

=========================
Create your own exeptions
=========================

Иерархия исключений Java не может предусмотреть все те ошибки, которые бы хотели исправить,
поэтому существует возможность создания собственных типов исключений.

Для создания собственного класса исключения нужно унаслодоваться от существующего типа исключения

    Пример:
                C:\Users\work\Desktop\java\filosofiaJava\src\exceptions\InheritingExeption.java


=============================
Display information exception
=============================

Информацию об исключениях можно вывести средствами java.util.logging

    Пример:
                C:\Users\work\Desktop\java\filosofiaJava\src\exceptions\LoggingExceptions.java

Исключения представляют собой разновидность объектов, процесс расширения функциональности классов
исключений можно продолжить

=======================
Exception specification
=======================

Рекомендуется сообщать программисту, использующему метод, об исключениях, который данный метод
может возбудить. Так как пользователь, использующий метод может заранее написать код для перехвата
возможных исключений. Синтаксис, называемый спецификацией исключений, является обязательным и является частью
объявления метода и следует сразу за списком аргументов.

    void method() throws TooBig, TooSmall, DivZero{}

Сообщить неверную информацию о возбуждаемых исключениях невозможно - если метод возбуждает исключение и не обрабатывает
их, то компилятор это увидит может либо обработать исключение, либо отметить в спецификации исключений.
неправильное использование механизма исключений выявляется при трансляции программы.

    Пример:
               C:\Users\work\Desktop\java\filosofiaJava\src\exceptions\question8\Question8.java

==============================
Catching any time of exception
==============================

Для обработки любых типов исключений достаточной перехватывать базовый класс Exception.

    catch(Exception e){
        System.err.println("Перехвачено исключение");
    }

Exception является бозовым классом исключения, но он не предоставляет информации о исключительной ситуации.
Для получения информации можно вызвать методы класса Exception, унаследованные от его собственного
базового класса Throwable.

String getMessage() - метод, получает детальное сообщение
String  getLocalizedMessage() - метод, получает локализованное сообщение
String toString() - метод, получает короткое сообщение объекта Throwable, включая при наличии детального сообщения

1) void printStackTrace()
2) void printStackTrace(PrintStream)
3) void printStackTrace(java.io.PrintWrite)

Методы, выводящие информацию об объекте Throwable и трассировку вызовов этого объекта.
Стек вызовов показывает последовательность вызова методов, которая привела к точке возникнования исключения.
Метод 1) отправляет информацию в стандартный поток для ошибок.
Методы 2) и 3) в поток по моему выбору

Throwable fillInStackTrace() - метод, записывает информацию о текущем состоянии кадров стека относительно текущего
объекта Throwable. Метод используется при повторном возбуждении или исключении.

Так же могут использоваться методы из типа Object.
getClass() - метод, возвращает информацию о классе объекта.
getName() - метод, возвращает имя класса, включающий информацию о пакете.
getSimpleName - метод, выводящий имя класса, без уточнений

    Пример:
            C:\Users\work\Desktop\java\filosofiaJava\src\exceptions\ExceptionMethod.java


===========
Stack trace
===========
getStackTrace() - метод, возвращает массив элементов трассировки стека; каждый элемент представляет кадр стека.
Нулевой элемент находится на вершине стека, и предоставляет информацию о последнем вызванном методе в последовательности

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\WhoCalled.java

===================================
Repeated excitation of an exception
===================================

Повторное возбуждение исключения

try{
    }catch(Exception e){
        System.err.print("Возбуждено исключение");
        throw e;
        }

    Повторное вобуждение исключение переходит в распоряжение обработчика исключений
более высокого уровня. Все следущие блоки catch игнорируются. Обрабочик тсключений высокого
уровня может извлечь всю информацию из дочернего класса исключения.
    При повторном возбуждении исключения, информация о нем, будет относиться к месту
где возникло исключение. Если нужная новая информация о трассировки стека,
метод fillInStackTrace() возвращает исключение(объект Throwable), созданное
на основе старой информации и включением туда текущей информации о стеке

    Пример:

        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\Rethrowing.java

Нет необходимости удалять предыдущие исключения, и вообще любые исключения.
Все исключения являются объектами, созданными в общей куче оператором new, и
уборщик мусора автоматические уничтожит их.

==================
Exception chaining
==================

Цепочка исключений - перехват исключения и возбуждение следующего, не теряя
информации о первом исключении.Все подклассы Trowable могут принимать в качестве
аргумента констрвктора объект-причину. Под причиной подразумевается изначальное
исключение, и передвая ее в новый объект, поддерживается трассировка стека вплоть
до самого начала, даже если создается и вобуждается новое исключение.

Существует всего 3 подкаласса класса Throwable, принимающие в качестве
аргумента объекта-причину:
    - Error
    - Exception
    - RunTime
Для организации цепочки из другиз типов исключений используется метод initCause()

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\DynamicFields.java

=======================
Java standard Exception
=======================

Все, что возбуждено как исключение, описываетя классом Throwable
Существует две разновидности Throwable:
    - Error, представляет  системные ошибки и ошибки времени компиляции.
    - Exception представялет любые исключения
Не все исключения определены в пакете java.lang, некоторые из них созданы для поддержки других библиотек,
таких как util, net и io

===============================
A special case:RuntimeException
===============================

if(t==null){
    throw new NullPointerException();
    }
Использования данного примера в качестве возбуждения исключения
избыточно, так как вызов этого вобуждения входит в стандартную
проверку во время выполнения Java-программы, и при использовании ссылки
содержащей null автоматически возбуждается NullPointerException
Существует целая группа исключений, возбуждающиеся в Java автоматически
и нет необходимости включать их в спецификацию исключений. Так как
они, исключения, унаследованы от базавого класса RuntimeException
Так же не нужно создавать спецификацию исключений, говорящую о том, что метод возбуждает
RuntimeException, так как эти исключения относятся к неконтролируемым(unchecked). Такие исключения
означают ошибки в программе, и фактически их не нужно перехватывать - это делается автоматически.

    Пример:
        C:\Users\work\Desktop\java\filosofiaJava\src\exceptions.NeverCaught.java

Механизм исключений Java направлен на обработку всех достадных ошибок программиста, выявленых во
врмея исполнения программы и обнаружения логических ошибок, обнаруженых компилятором

=======================
Completion with finally
=======================

Блок finally используется, например, в ситуациях, когда программа должна выполняться
независимо, возбуждено ли исключение внутри блока try(например, операция освобождения
памяти)

try{
    //охраняемая секция: небезопасные операции
    //которые могут возбуждать исключения А,В и С
    }catch(A a1){
    //Обработка для ситуации А
    }catch(B b1){
    //Обработка для ситуации В
    }catch(C c1){
    //Обработка для ситуации С
    }finally{
    //Действия, производимые в любом случае
    }

    Пример:

        C:\Users\work\Desktop\java\filosofiaJava\src\exceptions\FinallyWorks.java





=========================
What is finally block for
=========================

Блок finally используется когда нужно вернуть в первоначальное состояние например открытый файл
или сетевое соединение

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\OnOffSwitch.java

=======================
Using finally on return
=======================

Блок finally выполняется всегда, метод может возвращать управление из нескольких
точек. ПРи этом важные завершающие действия будут выполнены

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\MultipleReturns.java

====================
Trap: Lost Exception
====================

Исключения сигнализируют о кризисе в программе и не должны игнорироваться, так как возможна его потеря.
Это производит при использовании finally в конструкции определенного типа

    Пример:
            C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\LostMessage.java

======================
Limitations Exceptions
======================
Limitations-Ограничения

При переопределении исключений вправе возбуждать только те исключения, которые были
описаны в методе базового класса. Программа, работающая с базовым классом, автоматически
сможет работать с объектом, произошедшим от базового, включая и исключения

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\question20\StormyInning.java

============
Constructors
============

Если возуждается исключение из конструктора эти финальные действия могут быть
выполнены ошибочно, так как конструктор приводит объект
в опеределенное начальное состояние, но может начать выполнять, напримерн открытие
файла, которое не будет правильно звершено, пока пользователь не вызовет завершающий
метод
    Проблема не может быть решена блоком finally, так как finally выполняется всегда
даже когда выполняется завершающий код до вызова какого-то метода. Если сбой в конструкторе
проиходит до того как он будет выполнен полностью, то он может не успеть создать
некоторую часть объекта, освобождаемого в finally.

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\InputFile.java

=============================
Indentification of exceptions
=============================
    При возбуждении исключения механизм обработки ищет первый подходящий обработчик,
в том порядке, в каком они записаны. Отождествление исключений не требует точного
соответствия между исключением и обработчиком. Объект порожденного класса подойдет
и для обработчика, изначально написанного для базового класса.
    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\Human.java

При попытке замаскировать производный класс исключения:
    try{
        throw new Sneeze();
     }catch(Annoyance a){
        //...
     }catch(Sneeze e){
        //...
     }
компилятор сообщит об ошибке, который ссобщит что предложение catch
никогда не выполнится.

===============================
Passing exception to the console
===============================
Простейший способ сберечь исключение - передать его за пределы метода main(),
на консоль. В примере рассматривается ситуация когда нужно открыть файл для
чтения:
    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\MainException.java

=============================================
Convert controlled exceptions to uncontrolled
=============================================

Возникают ситуации когда нет понятия как обработать ошибку, поэтому, считается
идеальным решение данной ситуации,
не "поглощать" исключение а просто "завернуть" в класс RuntimeException,
благодаря цепочкам исключений:

    try{
        //нормальное решение проблемы
        }catch(НеЗнаюКакОбработатбИсключение е){
            throw new RuntimeException(e);
            }
это пример "отключения" контролируемого исключения

    Такой прием дает возможность игнорировать исключение и пустить его "всплывать"
вверх по стеку вызова без необходимости писать конструкции try-catch и/или
спецификации исключений.

    Пример:
        C:\Users\tony\IdeaProjects\filosofiajava\src\exceptions\TurnOffChecking.java

=============================
Guidlist for using exceptions
=============================
Использовать исключение для того, чтобы:

1.Обрабатывать ошибку на текущем уровне(Не перехватывать исключения если не знаю как поступить)
2.Исправить проблему и снова вызвать метод, возбудивший исключение.
3.Предпринять необходимые действия и продолжить выполнение без повторного вызова метода
4.Попытаться найти альтернативный результат, вместо того, который должен был бы произвести
вызванный метод.
5.Сделать все в текущем контексте, и заново возбудить это же исключение, перенаправиви
его на более высокий уровень.
6.Сделать все в текущем контексте, и возбудить новое исключение, перенаправив
его на более высокий уровень.
7.Завершить программу.
8.Упростить программу(не использовать схему обработки исключения, если она все
усложняет)
9.Повысить уровень безопасности библиотеки и программы(Помощь в отладке программы)


