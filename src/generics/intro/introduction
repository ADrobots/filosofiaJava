+++++++++++++
GENERIC TYPES
+++++++++++++
    Обычные классы и методы работают с конкретными типами: примитивными и классами.
    Один из механизмов обощения в объектно-ориентированном языке основан на полиморфизме.
К примеру, метод получающий в аргументе объекта базовый класс, использует этот метод
для любых кдасслв, производных от базового. Метод стал общим и может использоваться в
большем количестве мест. Этот принцип действует и в отношении других классов -
в любом месте, гже может использоваться конкретный тип, можно использовать базовый
класс для повышения гибкости
    Иногда ограничение одной иерархии оказывается слишком жестким. Если аргументом
метода является интерфейс(вместо клласса), то ограничения ослабляются до любой
релизации этого интрфейса - включая классы, которые еще не были созданы. Таким образом
интерфесы позволяют расширить обобщение между иерархиями классов.
    В некоторых ситуациях даже вариант с интерфейсом оказывается недостатчно гибким.
Чтобы писать еще более общий код, необходимо иметь возможность указать, что код
работает с неким "условным типом"(в отличии от конкретного интерфейса или класса)
    В этом заключается суть мехизма обобщенных типов(или обощенных(generics)).
Обобщения реализуют концепцию параметризированных типов, позволяющих создавать
компоненты(прежде всего контейнеры), которые удобно испольовать с разными типами.
    Когда создаем экземпляр параметризованного типа, все приведения типов выполняются
за нас, а правильность типов проверяется во время компиляции.

=====================
Simple generalization
=====================
    ОДна из причин использования обобщений - классы контейнеры. Контейнер представляет
СОбой хранилище объектов, с которыми работает программа(тоже можно сказать и о массивах).
В любой программа возникает необходимость хранения используемых объектов в контейнере,
поэтому контейнеры относятся к наиболее используемым библиотекам классаов.
    Пример класса, предназначенный для хранения одного объекта.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\Holder1.java
    Чаще всего в контейнере рахмещаются объекты одного типа. Одна из причин использования
обобщеных типов - возможность указать какой тип объектов должен храниться в контейнере,
и чтобы эта информация контролировалась компилятором.
    В следующем примере, вместо использования Object желательно использовать условный тип,
который будет определяться позднее. Для этого укахывает ся параметр-тип в укловых скобках
после имени класса, а при использовании заменяется фактическим типов.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\Holder3.java
    Принцип обобщеных типов таков: сообщается какой тип будет использоваться,
а обобщение берет на себя все подробности.
    В общем случае работаем с обобщениями точно так же, как слюбым другим типом -
просто у обобщений имеются параметры-типы.

=============
Tuple library
=============
//tuples - кортержи
    На практике, при вызове метода, необходимо вернуть несколько объектов. Команда return
позволяет вернуть только один объект, поэтому задачу приходилось решать созданием
объекта, содержащего несколько возвращаемых объектов. Можно всякий раз писать специалный класс,
когда возникает необдимость, но обобщения позволяют решать эту задачу один раз. Такое решение
гарантирует безопастность типов во время компиляции.
    Группа объектов, "завернутых" в один объект называется кортежем(tuple). Получатель объекта
может читать элементы, но не может добавлять новые.(концепция называется  "объектом передачи данных".
    Обычно кортеж имеет произвольную длину, но все объекты кортежа могут относиться к разным типам.
Например: хотим задать тип каждого объекта и убедться в том, что чтение значения получатель
получит правильный тип. Для решения проблемы с разной длиной можно создать несколько разных кортежей.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\TwoTuple.java
    Для создания кортежей большой длины можно применить наследование. Добавить новые параметры-типы:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\ThreeTuple.java
    Чтобы использовать кортеж, определяется объект с нужной длиной как
возвращаемое значение функции, а затем создается и возвращается объект
в команде return:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\TupleTest.java
Новые выражения громоздкие. Далее будет приведены примеры использования обобщеных методов.

===========
Class stack
===========
    Традиционный стек, который был рассмотрен в главе 11(chapter11.Stack), представленнsq на базе LinkedList,
содержащий методы для создания стека. Стек конструировался посредством композиции
обобщенного класса Stack<T> c другим обобщенным классом(LinkedList<T>). Обобщенный тип вел
себя как самый обычный тип.
    Вместо использования LinkedList можем реализовать мехнизм внутреннего хранения данных.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\LinkedStack.java

==========
RandomList
==========
    Другой пример, создадим особую разновидность списка, которая слчайным образом выводит
один из своих элементов вызовом метода select(). Чтобы реализация такого списка работала
с лююым объектом, следует использовать обобщение

==================
Generic Interfaces
==================
    Обобщения так же работают с интерфейсами. Генератор-это класс создания объектов.
Является разновидностью паттерна Фабричный метод, но запрашивая новый объект не нужно передавать
аргументы. Генератор умеет создавать новые объекты без дополнительной информации
    Генератор определяет только один метод, назовем его next()
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\coffee\Generator.java
    Для демонстрации реализации Generator понадобятся классы из пакета:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\coffee
    Теперь можем реализовать интерфейс Generator<Coffee> для создания случайных
объектов Coffee
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\coffee\CoffeeGenerator.java
    В примере необходим сторож, для обнаружения завершения
перебора, который создается во втором конструкторе.
    Вторая реализация Generator<T> для генерирования чисел
Фибоначчи
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\Fibonacci.java
    Далее создадим генератор чисел Фибоначчи, реализующий Iterable. Возможно повторная
реализация класса(Fibonacci)c добавлением интерфейса Iterable. Дабы не переписывать
код создадим "адаптер", предоставляющий нужный интерфейс.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\generics\IterableFibonacci.java