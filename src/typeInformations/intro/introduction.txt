+++++++++++++++++++++++
   TYPE INFORMATION
+++++++++++++++++++++++

RTTI(run-time type identification) - механизм динамического определения типов, который
позволяет получить и использовать информацию о типах во время выполнения программы.

Вообще судествует два способа извлечения информации о типе, это RTTI, так же
reflection - механизм отражения во время выполнения программы.

==============================================
Необходимость в динамическом определении типов
The need for dynamic type determination
==============================================
determination - определение

Рассмотрим пример:
Иерархия классов этого примера использует полиморфизм.
Базовым классом является Shape(фигура).
Производными классами являются Triangle, Circle, Square
Создаем объектр конкретного класса(Triange, Circle, Square)
производим восходящее преоразование к фигуре Shape и используем
ссылка на безымянную фигуру
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Shapes.java

Возникают случаи кода нужно знать точный тип объекта, обладая ссылкой
только базового класса. Например, нужен метод, переворачивающий фигуру,
при том, что КРУГ нет смыла переворачить. В таком случае нет смысла вы
зывать метод. Подобную задачу помогает решать  RTTI: определяющий точный
тип объекта и отобрать объекты, требующие вызова метода лдя преворачивания фигуры

============
Object Class
============

Во время выполнения программы информация о типе содержится в специальном объекте типа Class.
Java выполняет операции RTTI даже при выполнении явного перобразования объета.

Для каждого класса, используемого в программе, существует свой объект Class. После написания и компиляции
нового класса для него создается объект Class(который хранится в одноименном файле c расширением .class)
Для создания объекта этого класса, JVM использует подсистему, называемую ЗАГРУЗЧИКОМ классов.

Все классы загружаются в JVM динамечски, при первом использовании класса, при первом обращении к статическому
члену класса.Создание нового объекта класса оператором new считается обращением к статическому члену класса.

Программа Java не загружается полностью в самом начале, ее фрагрменты загружаются динамечески по
мере необходимости.

Загрузчик классов проверяет, загружен ли объект Class для указанного типа. Если файл не найдет, закгрузчик
по умолчанию ищет файл .class с соответствующим именем. В процессе загрузки испольнительная сиситема(JRE)
проверяет байт-код на наличие повреждений и содержание некорректного кода Java.

Когда объект Class окажется в памяти, в дальнейшем он используется при создании всех объектов этого типа
    Пример:
        C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\SweetShop.java




В каждом классе имеется статический блок, который отработат один раз при первой загрузке класса
В методе main() создаются объкты, чередуясь выводами на экран сообщений для правильного определения
загрузки класса.
Каждый объект Class загружается только если есть в этом необходимость, а "статическая"
инициализация происходит при загрузке этого объекта.

Class.forName("Gum") - это вызов статического метода класса Class. МОжем создавать его
и манипулировать ссылками на него.
Один из способов получения ссылки на объект Class - вызвать метод forName(), передав
ему в качестве аргумента строку String c именем определенного класса. Этот метод
возвращает ссылку на объект типа Class, которая игнорировалась.В процессе загрузки
выполняется static-инициализатор класса Gum.
В примере, если бы метод Class.forName() завершился неудачей(не смог найти класс,
который хотели загрузить), он возбудил бы исключение ClassNotFoundException.
Если хотим получить информацию о типе во время выполнения, сначала нужно получить
ссылку на соответствующий объект Class. Для этого лучше использовать  метод
Class.forName(), потому что для получения ссылки на Class объект не нужен.
Но если имеется объект интересующего типа, для получения ссылки на Class можно
вызвать метод, являющийся частью корневого класса Object - getClass(). Метод возвращает
ссылку на объект Class, представляющий фактический тип объекта.

Class содержит много интересных методов, вот несколько из них:
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\ToyTest.java

    ==============
    Literals class
    ==============
    В Java есть еще один способ получить ссылку на объект Class - посредством
    литерала class. Мы получим ее таким образом:
        Gum.class
Это не только проще но и безопаснее, т.к. проверка происходит еще во время кмпиляции.
Без вызова метода это более эффективнее.
Литералы работают с классами, интерфейсами, массивами и примитивами. Во всех классах-
оболочках для простейщих типов иммется поле с именем TYPE. Это поле содержит ссылку
 на объект Class для ассоциированного с ним простейшим типом.
 В таблице, на странице 459, приведены альтернативные обозначения оъектов класс с
 помощью литерала.
 При создании ссылки на объект Class не происходит автоматической инициализации объекта Class.
 Подготовка класса состоит из трех шагов:
    * Загрузка, выполняемая загрузчиком классов. Загрузчик находит байт-код и создает
    на его основе объект Class.
    * Компоновка. Проверяется байт-код класса, выделяется память под статические поля,
    при необходимости разрешает все ссылки на другие классы, используемые текущим клссом.
    * Инициализация. Если у класса имеется суперкласс, выполняется его инициализация.
    Также выполняются статический инициализаторы и блоки статической инициализации.
 Инициализация окладывается до первого обращения(конструкторы неявно являются статическми)
 или не-константному статическому полю,
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\ClassInitialization.java

=================================
References to generalized classes
=================================
Ссылка на Class, в действительности точно обозначает тип объекта, на который она
указывает: это объект класса Class. Ситуация стала чуть более конкретной за счет ограничения типа объекта Class, на который
указывает ссылка при помощи синтаксиса обобщенных типов.
Примеры обоих вариантов синтаксиса верны.
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\GenericClassReferences.java

Для ослабления ограничения при использовании параметризованых ссылок на Class
применяется метасимвол "?", вляющийся частью обобщенных типов и может означать
что угодно. Если добавить метасимвол "?" в обычную ссылку на Class, в приведенном примере
результат останется неизменным.
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\WildcardReferences.java

Class<?> является предпрчтительной по сравнению с Class. Эти две формы эквиваленты.
Преимущество записи Class<?> показывает: что разработчик сознательо выбирает неконкретную
версию.
Чтобы создать ссылку на Class, ограниченную типом или любым его подтипами,
метасимвол "?" следует объединять с ключевым словом extends для создания привзки
Поэтому вместо Class<Number> используется следующая запись
    Пример:
************должен загрузиться кусок коммита из дома***********

Предложение if проверяет, принадлежит ли x классу Dog, прежде чем выполнить приведение к типу Dog.
Рекомендуется использовать ключевое слово inctanceof перед приведением нисходящего преобразования.
С помощью instanceof можно подсчитать все типы объекта.
    Пример:
        typeInformations.pets.*java
        +
        typeInformations.PetCount.java

====================
Using class literals
====================
    Программа получается компактной, если использовать в PetCreator литералы class
        Пример:
            C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\LiteralPetCreator.java

В библиотеке typeInformations.pets теперь две реализации PetCreator. Чтобы вторая реализация использовалась
по умолчанию, мы можем предоставить реализацию паттерна "Фасад", использующая LiteralPetCreator:
        Пример:
            C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\pets\LiteralPetCreator.java

====================
Registered factories
====================
У системы генерации объектов Pet есть недостаток, так как каждый раз добавляя
новый тип Pet,нужно добавть данные в LiteralPetCreator.java
Поэтому нужно добавлять в каждый субкласс статический инициализатор, который будет
добавлять свой класс в некий список.
Придется создавать список самостоятельно, вручную. Лучшее разрешение этой ситуации -
разместить список в каком-то очевидном месте. Лучшее место - базовый класс иерархии.
Таж нужно внести другое изменение - создать объект с использование паттерна "Фабричный метод".
Фабричный метод может создаваться полиморфно и создает объекто нужного типа.
В данном примере простой версией "фабричным" является метод create() интерфейса Factory:
        Пример:
            typeInformations.factory.Factory
В следущем примере базовый класс Pet содержит контейнер List
с "фабричными" объектами. Фабрики типов, которые должны производиться методом createRandom()
регистрируются в базовом классе посредством добавления в список partFactories
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\RegisteredFactories.java

=======================================
instanceof and comprasion objects CLass
=======================================
    При получении информации о типе объекто в важно различать действия любой формы
оператора inctanceof и прямого сравнения объектов Class. Слудующий пример показывает
чем они отличаются:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\FamilyVsExactType.java

=====================================
Refletcion: dynamic type informations
=====================================
    Если точный тип не известен, RTTI собщит нам его. Другими словами, компилятор должен распологать
информацией обо всеъ класса, с которым вы работаете.
    Поддержка динамической информации о классе - возможность создания и использования объектов
на удаленной платформе. Такая возможность называется удаленным вызовом методов(RMI).
    Класс Class вводит понятие отражение(reflection), для которой существует библиотека
java.lang.reflection, состоящая из классов Field, Method и Constructor(каждая реализует интерфейс
Member). Объекты этих классов создаются JVM, для представления соответствующих
членов неизвестного класса. Можем использовать объекты Constructor для создания новых
объектов класса, методы get() и set() - для чтения и записи полей класса, представленных
объектами Field, метод invoce() - для вызова метода, представленного объектом Method.
В классе Class имеются удобные методы getFields(), getMethods() и getConstructirs(), которые
возвращают массивы таких объектов, как поля класса, методы и конструкторы.
Таким образом информация о неизвестном объекте доступна во время выполнения программы,
и потребность  в получении во время компиляции отпадает.
    Заключение:
    Разница между RTTI и отражением(reflection) в том, что при использовании RTTI файл
.class открывается и изучается компилятором. Методы объекта можем вызывать "обычным"
способом. При работе с отражеием, файл .class во время компиляции недостумен, он открывается
и обрабатывается системой выполнения.

=============================
Method information extraction
=============================
    Отражение редко используется напрямую, в основном для поддержки сериализации
объектов.Существуют ситуации, когда динамическая информация о классе назмаменима.
Наример, программа выводящая все методы определенного класса, в том числе базового.
С помощью отражения можно написать простой инструмент который показывает полный
интерфейс класса.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\ShowMethods.java
Данная программа при вызове помогает оперативно получить информацию о наличии
того или иного метода.

====================
Dynamic substituents
====================
//substituens - заместители
Заместитель(proxy) - основной паттерн проектирования.
Представляет собой объект, который подставляется на место настоящего объекта для
предоставления дополнительных операций, подразумевающих взаимодествие с настоящим
объектом. Заместитель чаще всего выполняет фунукции посредника.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\SimpleProxyDemo.java
Заместитель может пригодится в ситуации, в которой требуется включить дополнительные операции
в любом месте, отличном от настоящего объекта.
Динамический заместитель Java продвигает концепцию на один шаг вперед: объект заместителя
создается динамически, а вызовы замещенных методов тоже обрабатываются динамически.
Пример SimpleProxyDemo переписан для использования динамического заместителя:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\SimpleDinamicProxy.java
Пример поиска конкретных методов в динамическом заместитетле
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\SelectingMethods.java
        В данном примере проверяются имена методов, но так же можно проверять и другие аспекты
    сигнатуры, в том числе и конкретные значения аргументов.

============
Null-objects
============
Отсутствие объекта представляется втроенным значением null, поэтому ссылку на объект
приходится каждый раз проверять на null. Null не имеет собственного поведения, поэтому
помогает концепция null-объекта.
Null-объект принимает сообщение и возвращает сообщение, указывающий на отсутствие объекта.
Null-объекты - это объекты, представляющие сущности в пространстве задачи.
        Например:
Во многизх задачах используется класс Person, представляющий человека. Если информация
о человеке отсутствует обычно используется null в качестве значения ссылки. Вместо этого
можно использовать null-объект. Null-объект реагирует на все сообщения, на которые реагирует
настоящий объект, так же существует способ проверки null-объективности - использование
идентификационного интерфейста:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Null.java
Данное решение позволяет использовать inctanceof для обнаружения null-объектов
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Person.java
Задача:
    Имеются в штате компании незаполненные вакансии.
    Пока вакансии не заполнены, заполнить null-объектами
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Position.java

Следующий класс, класс Staff может проверять null-объекты при заполнении вакансий:
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Staff.java
Лишние проверки на null не нужны, все ссылки на объекты являются действительными.
    При работе с интерфейсами вместо конкретных классов, для автоматического создания
null объектов можно использовать динамические заместители.
        Например:
Интерфейс Robot определяет название, модель и список List<Operation> c описанием функций
робота. Объект Operation содержит описание и команду.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Operation.java
В программе может использоваться много разновидностей Robot, соответствено объект
null-объект должен делать чтото особенное для каждого типа Robot - например включение
информации о точном типе Robot. Эта информация сохраняется динамическим заместителем.
        Пример:
            C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\NullRobot.java

============================
Fictitious objects and stubs
============================
    //stubs-заглушки
        Вариации null-объекта - фиктивный объект(Mock object) и заглушка(stub).
Обе модели являются дублерами для настоящего объекта, который будет использоваться в программе.
Фиктивные объекты притворяются полноценными обектами, поставляющие реальную ифнормация, в отличие
от null-объектов.
Различия:
Заглушка представляет сложный объект, которвый реализует много разных функций.
Фиктивные объекты создаются в множестве простых объектов для выполнения разнообразных функций.
