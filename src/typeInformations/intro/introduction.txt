+++++++++++++++++++++++
   TYPE INFORMATION
+++++++++++++++++++++++

RTTI(run-time type identification) - механизм динамического определения типов, который
позволяет получить и использовать информацию о типах во время выполнения программы.

Вообще судествует два способа извлечения информации о типе, это RTTI, так же
reflection - механизм отражения во время выполнения программы.

==============================================
Необходимость в динамическом определении типов
The need for dynamic type determination
==============================================
determination - определение

Рассмотрим пример:
Иерархия классов этого примера использует полиморфизм.
Базовым классом является Shape(фигура).
Производными классами являются Triangle, Circle, Square
Создаем объектр конкретного класса(Triange, Circle, Square)
производим восходящее преоразование к фигуре Shape и используем
ссылка на безымянную фигуру
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\Shapes.java

Возникают случаи кода нужно знать точный тип объекта, обладая ссылкой
только базового класса. Например, нужен метод, переворачивающий фигуру,
при том, что КРУГ нет смыла переворачить. В таком случае нет смысла вы
зывать метод. Подобную задачу помогает решать  RTTI: определяющий точный
тип объекта и отобрать объекты, требующие вызова метода лдя преворачивания фигуры

============
Object Class
============

Во время выполнения программы информация о типе содержится в специальном объекте типа Class.
Java выполняет операции RTTI даже при выполнении явного перобразования объета.

Для каждого класса, используемого в программе, существует свой объект Class. После написания и компиляции
нового класса для него создается объект Class(который хранится в одноименном файле c расширением .class)
Для создания объекта этого класса, JVM использует подсистему, называемую ЗАГРУЗЧИКОМ классов.

Все классы загружаются в JVM динамечски, при первом использовании класса, при первом обращении к статическому
члену класса.Создание нового объекта класса оператором new считается обращением к статическому члену класса.

Программа Java не загружается полностью в самом начале, ее фрагрменты загружаются динамечески по
мере необходимости.

Загрузчик классов проверяет, загружен ли объект Class для указанного типа. Если файл не найдет, закгрузчик
по умолчанию ищет файл .class с соответствующим именем. В процессе загрузки испольнительная сиситема(JRE)
проверяет байт-код на наличие повреждений и содержание некорректного кода Java.

Когда объект Class окажется в памяти, в дальнейшем он используется при создании всех объектов этого типа
    Пример:
        C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\SweetShop.java




В каждом классе имеется статический блок, который отработат один раз при первой загрузке класса
В методе main() создаются объкты, чередуясь выводами на экран сообщений для правильного определения
загрузки класса.
Каждый объект Class загружается только если есть в этом необходимость, а "статическая"
инициализация происходит при загрузке этого объекта.

Class.forName("Gum") - это вызов статического метода класса Class. МОжем создавать его
и манипулировать ссылками на него.
Один из способов получения ссылки на объект Class - вызвать метод forName(), передав
ему в качестве аргумента строку String c именем определенного класса. Этот метод
возвращает ссылку на объект типа Class, которая игнорировалась.В процессе загрузки
выполняется static-инициализатор класса Gum.
В примере, если бы метод Class.forName() завершился неудачей(не смог найти класс,
который хотели загрузить), он возбудил бы исключение ClassNotFoundException.
Если хотим получить информацию о типе во время выполнения, сначала нужно получить
ссылку на соответствующий объект Class. Для этого лучше использовать  метод
Class.forName(), потому что для получения ссылки на Class объект не нужен.
Но если имеется объект интересующего типа, для получения ссылки на Class можно
вызвать метод, являющийся частью корневого класса Object - getClass(). Метод возвращает
ссылку на объект Class, представляющий фактический тип объекта.

Class содержит много интересных методов, вот несколько из них:
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\ToyTest.java

    ==============
    Literals class
    ==============
    В Java есть еще один способ получить ссылку на объект Class - посредством
    литерала class. Мы получим ее таким образом:
        Gum.class
Это не только проще но и безопаснее, т.к. проверка происходит еще во время кмпиляции.
Без вызова метода это более эффективнее.
Литералы работают с классами, интерфейсами, массивами и примитивами. Во всех классах-
оболочках для простейщих типов иммется поле с именем TYPE. Это поле содержит ссылку
 на объект Class для ассоциированного с ним простейшим типом.
 В таблице, на странице 459, приведены альтернативные обозначения оъектов класс с
 помощью литерала.
 При создании ссылки на объект Class не происходит автоматической инициализации объекта Class.
 Подготовка класса состоит из трех шагов:
    * Загрузка, выполняемая загрузчиком классов. Загрузчик находит байт-код и создает
    на его основе объект Class.
    * Компоновка. Проверяется байт-код класса, выделяется память под статические поля,
    при необходимости разрешает все ссылки на другие классы, используемые текущим клссом.
    * Инициализация. Если у класса имеется суперкласс, выполняется его инициализация.
    Также выполняются статический инициализаторы и блоки статической инициализации.
 Инициализация окладывается до первого обращения(конструкторы неявно являются статическми)
 или не-константному статическому полю,
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\ClassInitialization.java

=================================
References to generalized classes
=================================
Ссылка на Class, в действительности точно обозначает тип объекта, на который она
указывает: это объект класса Class. Ситуация стала чуть более конкретной за счет ограничения типа объекта Class, на который
указывает ссылка при помощи синтаксиса обобщенных типов.
Примеры обоих вариантов синтаксиса верны.
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\GenericClassReferences.java

Для ослабления ограничения при использовании параметризованых ссылок на Class
применяется метасимвол "?", вляющийся частью обобщенных типов и может означать
что угодно. Если добавить метасимвол "?" в обычную ссылку на Class, в приведенном примере
результат останется неизменным.
    Пример:
        C:\Users\tony\IdeaProjects\filosofiaJava\src\typeInformations\WildcardReferences.java

Class<?> является предпрчтительной по сравнению с Class. Эти две формы эквиваленты.
Преимущество записи Class<?> показывает: что разработчик сознательо выбирает неконкретную
версию.
Чтобы создать ссылку на Class, ограниченную типом или любым его подтипами,
метасимвол "?" следует объединять с ключевым словом extends для создания привзки
Поэтому вместо Class<Number> используется следующая запись
    Пример:


    ************должен загрузиться кусок коммита из дома***********

Предложение if проверяет, принадлежит ли x классу Dog, прежде чем выполнить приведение к типу Dog.
Рекомендуется использовать ключевое слово inctanceof перед приведением нисходящего преобразования.
С помощью instanceof можно подсчитать все типы объекта.
    Пример:
        typeInformations.pets.*java
        +
        typeInformations.PetCount.java

====================
Using class literals
====================
    Программа получается компактной, если использовать в PetCreator литералы class
        Пример:
            C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\LiteralPetCreator.java

В библиотеке typeInformations.pets теперь две реализации PetCreator. Чтобы вторая реализация использовалась
по умолчанию, мы можем предоставить реализацию паттерна "Фасад", использующая LiteralPetCreator:
        Пример:
            C:\Users\work\Desktop\java\filosofiaJava\src\typeInformations\pets\LiteralPetCreator.java

